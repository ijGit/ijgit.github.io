{"componentChunkName":"component---src-templates-post-js","path":"/pages/dp_1","result":{"data":{"markdownRemark":{"html":"<h1 id=\"1-동적-계획법-dp-dynamic-programming\" style=\"position:relative;\"><a href=\"#1-%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95-dp-dynamic-programming\" aria-label=\"1 동적 계획법 dp dynamic programming permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 동적 계획법 (DP, Dynamic Programming)</h1>\n<p>동적 계획법이란 복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법을 일컷는다. 이를 사용하여 반복적인 계산을 줄이고 효율적으로 최적해를 찾아낼 수 있다.</p>\n<p>DP의 일반적인 원리는 주어진 문제에서 입력 크기가 작은 부분 문제 (subproblem)들을 해결한 뒤에, 그 해들을 결합하여 원래 주어진 입력의 문제를 해결하는 것이다.\n이러한 방법으로 DP 는 불필요한 계산횟수를 줄이고 최적해를 찾아낼 수 있다. (즉, 최적화 문제를 해결한다.)</p>\n<p>DP 를 이용하면 부분 문제 반복과 최적 부분 구조 (optimal substructure)를 가지고 있는 문제들을 일반적인 방법에 비하여 적은 시간 내에 해결할 수 있다.</p>\n<br>\n<p><strong><em>주요 용어</em></strong></p>\n<ul>\n<li>\n<p>subproblem</p>\n<ul>\n<li>원래 문제보다 입력의 크기가 작은 동일한 문제를 말한다.</li>\n</ul>\n</li>\n<li>\n<p>optimal substructure</p>\n<ul>\n<li>어떤 문제의 최적해가 그것의 <code class=\"language-text\">subproblem</code>들의 최적해로부터 효율적으로 구해질 수 있을 때, 해당 문제는 <code class=\"language-text\">optimal substructure</code>를 가진다고 할 수 있다.</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"2-dynamic-programming-적용\" style=\"position:relative;\"><a href=\"#2-dynamic-programming-%EC%A0%81%EC%9A%A9\" aria-label=\"2 dynamic programming 적용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Dynamic Programming 적용</h1>\n<h4 id=\"dp-적용-조건\" style=\"position:relative;\"><a href=\"#dp-%EC%A0%81%EC%9A%A9-%EC%A1%B0%EA%B1%B4\" aria-label=\"dp 적용 조건 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DP 적용 조건</h4>\n<ul>\n<li>\n<p>최적 부분 구조 (optimal substructure)</p>\n<ul>\n<li>큰 문제의 최적해에 작은 문제의 최적해가 포함된다.</li>\n<li>= 순환식으로 (재귀적으로) 표현이 가능하다.</li>\n<li>해당 문제를 재귀적 해법으로 풀면 같은 문제에 대한 재귀 호출이 매우 많이 중복된다.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"dp-적용-방법\" style=\"position:relative;\"><a href=\"#dp-%EC%A0%81%EC%9A%A9-%EB%B0%A9%EB%B2%95\" aria-label=\"dp 적용 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DP 적용 방법</h4>\n<ol>\n<li>전체 문제를 작은 문제로 단순화 한다. (주어진 문제에 대한 최적 부분 구조를 찾는다)</li>\n<li>문제를 재귀적인 구조로 표현한다. (순환식을 정의한다)</li>\n<li>작은 문제를 해결하는 방법으로 전체 문제를 해결한다. (문제를 푼다)</li>\n</ol>\n<h2 id=\"21-dp-problem-피보나치-수열\" style=\"position:relative;\"><a href=\"#21-dp-problem-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%EC%88%98%EC%97%B4\" aria-label=\"21 dp problem 피보나치 수열 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1. DP Problem: 피보나치 수열</h2>\n<h4 id=\"1-recursion\" style=\"position:relative;\"><a href=\"#1-recursion\" aria-label=\"1 recursion permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1) Recursion</h4>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">1</span> <span class=\"token operator\">||</span> n<span class=\"token operator\">==</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span> <span class=\"token keyword\">return</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>해당 <code class=\"language-text\">fib</code> 함수로 계산을 하면 많은 중복 계산이 발생하게 된다.</p>\n<h4 id=\"2-memoization\" style=\"position:relative;\"><a href=\"#2-memoization\" aria-label=\"2 memoization permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2) Memoization</h4>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> f<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">1</span> <span class=\"token operator\">||</span> n<span class=\"token operator\">==</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> f<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 이미 계산됨 -> 캐싱한 값을 리턴하여 중복 계산을 피함</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n        f<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> f<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>memoization 은 <code class=\"language-text\">f[n] = fib(n-1) + fib(n-2);</code> 에서 처럼 caching 된 중간 계산 결과를 사용함으로써 중복 계산을 피한다.</p>\n<h4 id=\"3-dynamic-programming\" style=\"position:relative;\"><a href=\"#3-dynamic-programming\" aria-label=\"3 dynamic programming permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3) Dynamic Programming</h4>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    f<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> f<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        f<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> f<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> f<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> f<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위처럼 문제를 푸는 방식을 bottom-up 방식이라 한다.\nDP 는 bottom-up 방식을 이용하여 중복 계산을 피한다.</p>\n<!-- \n\n\n### DP Problem 2: 이항 계수\n\n#### Recursion \n#### Memoization\n#### Dynamic Programming\n\n\n\n\n### DP Problem 3: 행렬 경로\n\n#### Recursion \n#### Memoization\n#### Dynamic Programming\n -->\n<h1 id=\"3-memoization-vs-dynamic-programming\" style=\"position:relative;\"><a href=\"#3-memoization-vs-dynamic-programming\" aria-label=\"3 memoization vs dynamic programming permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Memoization vs Dynamic Programming</h1>\n<p>Memoization (메모이제이션)과 DP (Dynamic Programming, 동적계획법)은 순환식의 값을 계산하는 기법으로 약간의 차이점이 존재하나 <em>둘 다 DP의 일종으로 간주</em>하기도 한다.</p>\n<h2 id=\"memoization\" style=\"position:relative;\"><a href=\"#memoization\" aria-label=\"memoization permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Memoization</h2>\n<ul>\n<li>Memoization은 top-down 방식이며, 실제로 필요한 subproblem 만을 푼다.</li>\n<li>Memoization은 recursion에 따른 오버헤드가 존재한다.</li>\n</ul>\n<h2 id=\"dynamic-programming\" style=\"position:relative;\"><a href=\"#dynamic-programming\" aria-label=\"dynamic programming permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Dynamic Programming</h2>\n<ul>\n<li>DP 는 bottom-up 방식이며, 모든 subproblem 을 푼다.</li>\n<li>DP는 recursion에 수반되는 오버헤드가 없다.</li>\n</ul>","frontmatter":{"date":"2020-11-30","title":"[Algorithm] 동적 계획법 (Dynamic Programming) 1","tags":["Algorithm"]},"fields":{"slug":"/pages/dp_1"},"tableOfContents":"<ul>\n<li><a href=\"/pages/dp_1/#1-%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95-dp-dynamic-programming\">1. 동적 계획법 (DP, Dynamic Programming)</a></li>\n<li>\n<p><a href=\"/pages/dp_1/#2-dynamic-programming-%EC%A0%81%EC%9A%A9\">2. Dynamic Programming 적용</a></p>\n<ul>\n<li><a href=\"/pages/dp_1/#21-dp-problem-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%EC%88%98%EC%97%B4\">2.1. DP Problem: 피보나치 수열</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"/pages/dp_1/#3-memoization-vs-dynamic-programming\">3. Memoization vs Dynamic Programming</a></p>\n<ul>\n<li><a href=\"/pages/dp_1/#memoization\">Memoization</a></li>\n<li><a href=\"/pages/dp_1/#dynamic-programming\">Dynamic Programming</a></li>\n</ul>\n</li>\n</ul>"}},"pageContext":{"slug":"/pages/dp_1"}},"staticQueryHashes":["1073894666","554375791"]}